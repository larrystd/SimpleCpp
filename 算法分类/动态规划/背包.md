#### 01背包

给定一组多个（$n$）物品，每种物品都有自己的重量（$w_i$）和价值（$v_i$），在限定的总重量/总容量（$C$）内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高。

即http://mohu.org/info/symbols/symbols.htm


$max \sum_{i=1}^n x_iv_i$

s.t $\sum_{i=1}^n x_iw_i \leq C$

$ x_i \in \{0, 1\} $

定义子问题, $P(i, W)$, 在前i个物品中挑选总重量不超过$W$(背包剩余容量为W)的物品, 每种物品至多选一个, 使总价值最大。这时的最优解记作$m(i, W)$

则
$m(i, W) = max\{m(i-1, W), m(i-1, W-w_i) + v_i\} $

综合边界条件

$i=0, m(i, W)=0$

$w=0, m(i, W)=0$

$w_i>W, m(i, W) = m(i-1, W)$


$otherwise, m(i, W) = max\{m(i-1, W), m(i-1, W-w_i) + v_i\}$

```py
举例

N = 3 //地主家有三样东西

wt = [2,1,3] //每样东西的重量

val = [4,2,3] //每样东西的价值

W = 4 //背包可装载重量

def kpack(N:int, wt:List[int], val:List[int], W:int) -> int:
    size = len(wt)
    m = [[0 for i in range(W + 1)] for j in range(N + 1)]

    #i 为选择的物品, j为剩余容量
    for i in range(1, N+1):
        for j in range(1, W+1):
            if wt[i-1] > j:
                m[i][j] = m[i-1][j]
            else:
                m[i][j] = max(m[i-1][j], m[i-1] [j-wt[i-1]]+val[i-1])
    print (m)
    return m[N][W]
```
#### 完全背包

与0-1背包问题不同的地方时，完全背包问题允许一件物品无限次的出现。

